Prerequisites-
1)An understanding of compiler steps.


2)19CSE401-Compiler Design

An intro to The bug-

The solidity blog-https://soliditylang.org/blog/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/


An intro to problem-optimizer steps. 
In solidity optimizer steps are used to efficiently optimize the compilation process.It works by r works by refining the unoptimized IR produced by the code generator in discrete steps, each one receiving the output of the previous one. The order of steps is determined by the step sequence.

What do you need-
1)An optimizer sequence that does not prepare the  prerequesites for Fullinliner or the expression inliner.
2)An Nested-Function call with side effects
3)Solidity Optimizer level between 0.6.7 and 0.8.21

1)Examples with inline assembly
Consider Example1.sol
```
contract C {
    function f() public {
        assembly  {
            function fun_revert() -> ret { revert(0, 0) }
            function fun_return() -> ret { return(0, 0) }
            function empty(a, b) {}

            empty(fun_return(), fun_revert())
        }
    }
}
```

It looks like a normal function right? But since it evaluates from right to left,this is a function that is expected to revert.

Consider what happens when i put an optimizer step "i"?
solc test.sol -o results --debug-info none   --overwrite --optimize --ir-optimized --yul-optimizations "i " 

                if iszero(lt(calldatasize(), 4))
                {
                    let value := calldataload(0)
                    let newValue := 0
                    newValue := shr(224, value)
                    let selector := newValue
                    if eq(0x26121ff0, newValue)
                    {
                        if callvalue() { revert(0, 0) }
                        let headStart := 4
                        let dataEnd := calldatasize()
                        if slt(sub(dataEnd, headStart), 0) { revert(0, 0) }
                        let usr$ret := 0
                        return(usr$ret, usr$ret)
                    }

It returns a value,that its not supposed to.This is very dangerous and can lead to Other outcomes.


2)Without inline Assembly(High level Language)

This is infinitely harder(The code generated by the IR-optimizer is mainly in the expression-split form, where each expression is assigned to a separate variable because code in this form is very easy to generate),But a little bit easier to understand With Context 

Lets Consider the  new default Optimizer Sequence for 0.8.27
```
dhfoDgvulfnTUtnIf xa[r]EscLM Vcul [j] Trpeul xa[r]cL gvifM CTUca[r]LSsTFOtfDnca[r]Iulc scCTUt gvifM x[scCTUt] TOntnfDIul gvifM
```

There's a glaring problem with this sequence,the prerequisites for r in which it recieves code in Non-expression-split-form and i(full-inliner) which recieves code in weak-Expression-Split-Form.*This is not a problem for code after solidity version 0.8.21*

Consider Example3.sol

You might have a few questions,
```
    function empty1(uint256 a, uint256 b) public  returns (uint256) {
        return add(a,b);
    }
    function empty(uint256 a) public  returns (uint256) {
      return empty1(a,add1(2, 3));
    }
    function trigger() public  returns (uint256) {
        return empty(add(x,2));
    }
```
*What is going on here?*

Well I tried to trick it into putting it into non-expression-split-form.

*Well it doesnt look like it*

Consider this 

```
            function fun_empty1(var_a, var_b) -> var
            { var := 0 }
            function fun_empty(var_a) -> var
            {
                var := fun_empty1(var_a, fun_add(0x02, 0x03))
            }
            function extract_from_storage_value_offsett_uint256(slot_value) -> value
            { value := shr(0, slot_value) }
            function fun_trigger() -> var_
            {
                var_ := fun_empty(fun_add(extract_from_storage_value_offsett_uint256(sload(0x00)), 0x02))
            }
```
When i call fun_empty() it directly puts fun_add(extract_from_storage_value_offsett_uint256(sload(0x00)), 0x02) into the empty1 call so i get 

var := fun_empty1(fun_add(extract_from_storage_value_offsett_uint256(sload(0x00)), 0x02), fun_add(0x02, 0x03))

Which would allow it to be inlined.

```
 function fun_empty(var_a) -> var
            {
                let var_a_1 := var_a
                let var_a_2 := 0x02
                let var_b := 0x03
                let var_1 := 0
                let slot := var_1
                let value := var_a_2
                sstore(var_1, update_byte_slice_shift(sload(var_1), var_a_2))
                var_1 := checked_add_uint256(var_a_2, var_b)
                let var_b_1 := var_1
                let var_2 := 0
                var_2 := checked_add_uint256(var_a, var_1)
                var := var_2
            }
            function fun_trigger() -> var
            {
                var := fun_empty(checked_add_uint256(extract_from_storage_value_offsett_uint256(sload(0x00)), 0x02))
            }
```

Notice how again it does it from left to right,Completely chaging the order that it is supposed to be in.This also returns a value of 17.

Now lets see what happens to it on a more stable version like 0.8.21

```
            function external_fun_trigger()
            {
                if callvalue() { revert(0, 0) }
                let _1 := 0
                if slt(add(calldatasize(), not(3)), _1) { revert(_1, _1) }
                let _2 := sload(_1)
                if gt(_2, not(2))
                {
                    mstore(_1, shl(224, 0x4e487b71))
                    mstore(4, 0x11)
                    revert(_1, 0x24)
                }
                sstore(_1, 0x02)
                let var := checked_add_uint256_906(add(_2, 0x02))
                let memPos := mload(64)
                mstore(memPos, var)
                return(memPos, 32)
            }
```

Notice How it does this in the proper order.Also notice that it being the same code it returns a value of 12.

Sequence used-solc t.sol -o results --debug-info none   --overwrite --optimize --ir-optimized --yul-optimizations "dhfoDgvlfnTUtnIf a[r]EscLM Vcl Trpel a[r]cL [j]  "
